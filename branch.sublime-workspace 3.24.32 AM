{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"bran",
				"branchesNotTaken"
			],
			[
				"predi",
				"predictionBPBIndex"
			],
			[
				"new",
				"newBufferEntry"
			],
			[
				"branch",
				"branchPredictionBuffer"
			],
			[
				"F",
				"FIRST_PREDICTION"
			],
			[
				"WEA",
				"WEAK_N_TAKEN"
			],
			[
				"branc",
				"branchPredictionBuffer"
			],
			[
				"pre",
				"branchPredictionBuffer"
			],
			[
				"IF",
				"IF_ID"
			],
			[
				"SE",
				"SETBOOKSTOCK"
			],
			[
				"SERV_POR",
				"SERV_PORT_STR"
			],
			[
				"SERV",
				"SERV_PORT_STR"
			],
			[
				"entry",
				"entrynumber"
			],
			[
				"free",
				"freebookdata"
			],
			[
				"sele",
				"selection_orders"
			],
			[
				"if",
				"if	if"
			],
			[
				"resp",
				"responseBaseBody"
			]
		]
	},
	"buffers":
	[
		{
			"file": "/Users/marcelotoledo/Desktop/branchpredictor.h",
			"settings":
			{
				"buffer_size": 1294,
				"line_ending": "Unix"
			}
		},
		{
			"file": "pipeline.h",
			"settings":
			{
				"buffer_size": 308,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/**\n * @file      mips1_isa.cpp\n * @author    Sandro Rigo\n *            Marcus Bartholomeu\n *            Alexandro Baldassin (acasm information)\n *\n *            The ArchC Team\n *            http://www.archc.org/\n *\n *            Computer Systems Laboratory (LSC)\n *            IC-UNICAMP\n *            http://www.lsc.ic.unicamp.br/\n *\n * @version   1.0\n * @date      Mon, 19 Jun 2006 15:50:52 -0300\n * \n * @brief     The ArchC i8051 functional model.\n * \n * @attention Copyright (C) 2002-2006 --- The ArchC Team\n * \n * This program is free software; you can redistribute it and/or modify \n * it under the terms of the GNU General Public License as published by \n * the Free Software Foundation; either version 2 of the License, or \n * (at your option) any later version. \n * \n * This program is distributed in the hope that it will be useful, \n * but WITHOUT ANY WARRANTY; without even the implied warranty of \n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \n * GNU General Public License for more details. \n * \n * You should have received a copy of the GNU General Public License \n * along with this program; if not, write to the Free Software \n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include  \"mips1_isa.H\"\n#include  \"mips1_isa_init.cpp\"\n#include  \"mips1_bhv_macros.H\"\n\n\n//If you want debug information for this model, uncomment next line\n//#define DEBUG_MODEL\n#include \"ac_debug_model.H\"\n\n// Container de C++\n#include <vector>\n#include <pipeline.h>\n#define FASES 5\n\n//!User defined macros to reference registers.\n#define Ra 31\n#define Sp 29\n\nstruct Onebit{\n	long int endereco;\n	bool state;\n};\n\n// 'using namespace' statement to allow access to all\n// mips1-specific datatypes\nusing namespace mips1_parms;\nusing namespace std;\n\nenum estagios\n{\n	IF_ID,\n	ID_EX,\n	EX_MEM,\n	MEM_WB\n};\n\n\nint forward1A = 0;\nint forward1B = 0;\nint forward2A = 0;\nint forward2B = 0;\nint withFstalls = 0;\nint noFstalls = 0;	// Numero Stalls na ausencia de forwards\n\nvector < fase > pipeline (FASES-1);\n// Exemplo: pipeline de 5 estagios\n//  IF | ID | EX | MEM | WB\n//    [0]  [1]  [2]   [3] \n\nvoid verificaStalls () {\n	if(pipeline[MEM_WB].init) {\n		if (pipeline[EX_MEM].regWrite &&\n				pipeline[EX_MEM].rd &&\n				pipeline[EX_MEM].rd == pipeline[ID_EX].rs) {\n			noFstalls += 2;		// 2 stalls se nao tivesse forward\n			forward2A++;\n		}\n		if (pipeline[EX_MEM].regWrite &&\n				pipeline[EX_MEM].rd &&\n				pipeline[EX_MEM].rd == pipeline[ID_EX].rt) {\n			noFstalls += 2;		// 2 stalls se nao tivesse forward\n			forward2B++;\n		}\n		if (pipeline[MEM_WB].regWrite &&\n				pipeline[MEM_WB].rd &&\n				pipeline[MEM_WB].rd == pipeline[ID_EX].rs\n				&&\n				!(pipeline[EX_MEM].regWrite && pipeline[EX_MEM].rd) \n		   ) {\n			if (pipeline[EX_MEM].rd != pipeline[ID_EX].rs) {\n				noFstalls += 1;		// 1 stall se nao tivesse forward\n				forward1A++;\n			}\n		}\n		if (pipeline[MEM_WB].regWrite &&\n				pipeline[MEM_WB].rd &&\n				pipeline[MEM_WB].rd == pipeline[ID_EX].rt\n				&&\n				!(pipeline[EX_MEM].regWrite && pipeline[EX_MEM].rd) \n		   ) {\n			if (pipeline[EX_MEM].rd != pipeline[ID_EX].rt) {\n				noFstalls += 1;		// 1 stall se nao tivesse forward\n				forward1B++;\n			}\n		}\n\n		if (pipeline[ID_EX].memRead &&\n			((pipeline[ID_EX].rt == pipeline[IF_ID].rs) ||\n			 (pipeline[ID_EX].rt == pipeline[IF_ID].rt)) )\n		{\n			withFstalls++;			// Hazard\n		}\n	} // if externo\n}\n\n//!Generic instruction behavior method.\nvoid ac_behavior( instruction )\n{\n	dbg_printf(\"----- PC=%#x ----- %lld\\n\", (int) ac_pc, ac_instr_counter);\n\n	verificaStalls();\n\n	if (pipeline[IF_ID].branch) {\n		cout << endl << \"acpc: \" << ac_pc << \" npc: \" << npc << endl;\n		if (pipeline[IF_ID].acpc == ac_pc) {\n			cout << \"Branch not taken \" << ac_pc << \" \" << pipeline[IF_ID].acpc << endl;\n		}\n		else {\n			cout << \"Branch taken\" << endl;\n		}\n	}\n\n	// Se a fase existir realmente\n	// Ou seja nao for a inicial\n	// Se o pipeline foi devidamente preenchido\n	// Ou seja o ultimo estagio esta' iniciado\n\n	//  dbg_printf(\"----- PC=%#x NPC=%#x ----- %lld\\n\", (int) ac_pc, (int)npc, ac_instr_counter);\n	//\n	//\n	//  Fazendo o pipeline rodar\n	pipeline.pop_back(); 		// Fim da fase WB\n	fase f(op,npc);		// Nova fase e Armazenando instrucao\n	f.init = true;			// Fase existente\n	//cout << op << endl;\n	//	pipeline.push_front(f);\n	pipeline.insert(pipeline.begin(),f);	// Nova fase no pipeline\n\n	// BRANCH PREDICTOR\n#ifndef NO_NEED_PC_UPDATE\n	ac_pc = npc;\n	npc = ac_pc + 4;\n#endif \n\n\n	if (op==50) {\n		cout << \"npc Geral: \" << npc << endl;\n		cout << \"second\" << endl;\n	}\n};\n\nint mytyper = 0;\nint mytypei = 0;\nint mytypej = 0;\n\nunsigned int exmem_rd = 1000, exmem_rs = 1000, exmem_rt = 1000;\nunsigned int memwb_rd = 1000, memwb_rs = 1000, memwb_rt = 1000;\n\nbool aux_mem = false;\nbool reg_write = false;\n\nint ex_hazards = 0;\nint mem_hazards = 0;\n\nbool load = false;\nint stall = 0;\n\nint branch_count = 0;\nint not_taken = 0;\nint always_taken = 0;\n\nOnebit one_bit_preditor[10000000];\nint one_bit_count = 0;\nbool branch_state_aux;\n\nbool naive = false;\nint naive_count = 0;\n\nvoid OneBitFunc(int imediato, bool branch_state){\n	for(int i = 0; i < 10000000; i++){\n		if (i == 9999999) printf(\"FODEUUUU\");\n		if (one_bit_preditor[i].endereco == imediato){\n			if (branch_state != one_bit_preditor[i].state){\n				one_bit_preditor[i].state = branch_state;\n				one_bit_count++;\n			}\n			break;\n		}\n		if (one_bit_preditor[i].endereco == 0){\n			one_bit_preditor[i].endereco = imediato;\n			if (branch_state != one_bit_preditor[i].state){\n				one_bit_preditor[i].state = branch_state;\n				one_bit_count++;\n			}\n			break;\n		}\n	}\n}\n\nvoid NaiveFunc(bool branch_state){\n	if (branch_state != naive) {\n		naive = branch_state;\n		naive_count++;\n	}\n}	\n\n//! Instruction Format behavior methods.\nvoid ac_behavior( Type_R ){ \n	// Registradores descobertos na fase IF->ID\n	pipeline[IF_ID].rd = rd;\n	pipeline[IF_ID].rs = rs;\n	pipeline[IF_ID].rt = rt;\n	mytyper++;\n\n\n	if (reg_write && (exmem_rd != 0) && ((exmem_rd == rs) || (exmem_rd == rt))) { // EX Hazard\n		aux_mem = true;\n		ex_hazards += 2;\n\n		if (load) stall++;\n		load = false;\n	}\n\n	if (reg_write && (memwb_rd !=0) && !(aux_mem) && ((memwb_rd == rs) || (memwb_rd == rt))) { // MEM Hazard\n		mem_hazards++;\n		// printf(\"2 - %d\\n\", mem_hazards);\n	}\n\n	aux_mem = false;\n	reg_write = false;\n\n	memwb_rd = exmem_rd;\n	memwb_rs = exmem_rs;\n	memwb_rt = exmem_rt; \n\n	// printf(\"BEFORE r%d, r%d, r%d\\n\", exmem_rd, exmem_rs, exmem_rt);\n\n	exmem_rd = rd;\n	exmem_rs = rs;\n	exmem_rt = rt;\n\n\n	// printf(\"TYPE_R r%d, r%d, r%d\\n\\n\", rd, rs, rt);\n\n}\n\nvoid ac_behavior( Type_I ){ \n	// Registradores descobertos na fase IF->ID\n	pipeline[IF_ID].rs = rs;\n	pipeline[IF_ID].rt = rt;\n	pipeline[IF_ID].imm = imm;\n\n\n//	cout << endl << op << endl;\n	mytypei++;\n\n	if (reg_write && (exmem_rd != 0) && ((exmem_rd == rs) || (exmem_rd == rt))) { // EX Hazard\n		aux_mem = true;\n		ex_hazards += 2;\n		// printf(\"1 - %d\\n\", ex_hazards);\n\n	}\n\n	if (reg_write && (memwb_rd !=0) && !(aux_mem) && ((memwb_rd == rs) || (memwb_rd == rt))) { // MEM Hazard\n		mem_hazards++;\n		// printf(\"2 - %d\\n\", mem_hazards);\n	}\n\n	aux_mem = false;\n	reg_write = false;\n\n	memwb_rd = exmem_rd;\n	memwb_rs = exmem_rs;\n	memwb_rt = exmem_rt; \n\n	// printf(\"BEFORE r%d, r%d, r%d\\n\", exmem_rd, exmem_rs, exmem_rt);\n\n	exmem_rd = rt;\n	exmem_rs = rs;\n	// exmem_rt = rt;\n\n	// printf(\"TYPE_I r%d, %d(r%d)\\n\\n\", rt, imm & 0xFFFF, rs);		\n}\n\nvoid ac_behavior( Type_J ){ \n	// Registradores descobertos na fase IF->ID\n	pipeline[IF_ID].addr = addr;\n	mytypej++;\n\n	memwb_rd = exmem_rd;\n	memwb_rs = exmem_rs;\n	memwb_rt = exmem_rt; \n\n	// 	printf(\"TYTPE_J %d\\n\", addr);\n}\n\nint nadds = 0;\n//!Behavior called before starting simulation\nvoid ac_behavior(begin)\n{\n	dbg_printf(\"@@@ begin behavior @@@\\n\");\n	RB[0] = 0;\n	npc = ac_pc + 4;\n\n	// Is is not required by the architecture, but makes debug really easier\n	for (int regNum = 0; regNum < 32; regNum ++)\n		RB[regNum] = 0;\n	hi = 0;\n	lo = 0;\n\n	for (int i = 0; i < 10000000; i++){\n		one_bit_preditor[i].endereco = 0;\n		one_bit_preditor[i].state = false;\n	} \n}\n\n//!Behavior called after finishing simulation\nvoid ac_behavior(end)\n{\n	dbg_printf(\"@@@ end behavior @@@\\n\");\n	printf(\"\\n---------- MINHAS SAIDAS ---------- \\n\\n\");\n	printf(\"Numero de ADDS: %d\\n\", nadds);\n	printf(\"TYPE_R: %d, TYPE_I: %d, TYPE_J: %d\\n\", mytyper, mytypei, mytypej);\n	printf(\"EX: %d, MEM: %d\\n\", ex_hazards, mem_hazards);\n	printf(\"Stall: %d\\n\", stall);\n	printf(\"Branch: %d | Not Taken: %d | Always Taken: %d\\n\", branch_count, not_taken, always_taken);\n	printf(\"1-bit Preditor: %d\\n\", one_bit_count);\n	printf(\"Naive: %d\\n\", naive_count);\n	printf(\"\\n---------- MINHAS SAIDAS ---------- \\n\\n\");\n	cout << forward1A << \" \" << forward1B << \" \" << forward2A << \" \" << forward2B << endl;\n\n	// Soma de stalls de com e sem forward. Totalizando os stalls\n	// do pipeline\n	cout << \"Numero de stalls se nao houvesse forward: \" << noFstalls+withFstalls << endl;\n	cout << \"Numero de stalls com forward: \" << withFstalls << endl;\n}\n\n\n//!Instruction lb behavior method.\nvoid ac_behavior( lb )\n{\n	char byte;\n	dbg_printf(\"lb r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	byte = DM.read_byte(RB[rs]+ imm);\n	RB[rt] = (ac_Sword)byte ;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n	load = true;\n};\n\n//!Instruction lbu behavior method.\nvoid ac_behavior( lbu )\n{\n	unsigned char byte;\n	dbg_printf(\"lbu r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	byte = DM.read_byte(RB[rs]+ imm);\n	RB[rt] = byte ;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n	load = true;\n};\n\n//!Instruction lh behavior method.\nvoid ac_behavior( lh )\n{\n	short int half;\n	dbg_printf(\"lh r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	half = DM.read_half(RB[rs]+ imm);\n	RB[rt] = (ac_Sword)half ;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n	load = true;\n};\n\n//!Instruction lhu behavior method.\nvoid ac_behavior( lhu )\n{\n	unsigned short int  half;\n	half = DM.read_half(RB[rs]+ imm);\n	RB[rt] = half ;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n	load = true;\n};\n\n//!Instruction lw behavior method.\nvoid ac_behavior( lw )\n{\n	dbg_printf(\"lw r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	RB[rt] = DM.read(RB[rs]+ imm);\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n	load = true;\n};\n\n//!Instruction lwl behavior method.\nvoid ac_behavior( lwl )\n{\n	dbg_printf(\"lwl r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	unsigned int addr, offset;\n	ac_Uword data;\n\n	addr = RB[rs] + imm;\n	offset = (addr & 0x3) * 8;\n	data = DM.read(addr & 0xFFFFFFFC);\n	data <<= offset;\n	data |= RB[rt] & ((1<<offset)-1);\n	RB[rt] = data;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n	load = true;\n};\n\n//!Instruction lwr behavior method.\nvoid ac_behavior( lwr )\n{\n	dbg_printf(\"lwr r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	unsigned int addr, offset;\n	ac_Uword data;\n\n	addr = RB[rs] + imm;\n	offset = (3 - (addr & 0x3)) * 8;\n	data = DM.read(addr & 0xFFFFFFFC);\n	data >>= offset;\n	data |= RB[rt] & (0xFFFFFFFF << (32-offset));\n	RB[rt] = data;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n	load = true;\n};\n\n//!Instruction sb behavior method.\nvoid ac_behavior( sb )\n{\n	unsigned char byte;\n	dbg_printf(\"sb r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	byte = RB[rt] & 0xFF;\n	DM.write_byte(RB[rs] + imm, byte);\n	dbg_printf(\"Result = %#x\\n\", (int) byte);\n};\n\n//!Instruction sh behavior method.\nvoid ac_behavior( sh )\n{\n	unsigned short int half;\n	dbg_printf(\"sh r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	half = RB[rt] & 0xFFFF;\n	DM.write_half(RB[rs] + imm, half);\n	dbg_printf(\"Result = %#x\\n\", (int) half);\n};\n\n//!Instruction sw behavior method.\nvoid ac_behavior( sw )\n{\n	dbg_printf(\"sw r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	DM.write(RB[rs] + imm, RB[rt]);\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n};\n\n//!Instruction swl behavior method.\nvoid ac_behavior( swl )\n{\n	dbg_printf(\"swl r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	unsigned int addr, offset;\n	ac_Uword data;\n\n	addr = RB[rs] + imm;\n	offset = (addr & 0x3) * 8;\n	data = RB[rt];\n	data >>= offset;\n	data |= DM.read(addr & 0xFFFFFFFC) & (0xFFFFFFFF << (32-offset));\n	DM.write(addr & 0xFFFFFFFC, data);\n	dbg_printf(\"Result = %#x\\n\", data);\n};\n\n//!Instruction swr behavior method.\nvoid ac_behavior( swr )\n{\n	dbg_printf(\"swr r%d, %d(r%d)\\n\", rt, imm & 0xFFFF, rs);\n	unsigned int addr, offset;\n	ac_Uword data;\n\n	addr = RB[rs] + imm;\n	offset = (3 - (addr & 0x3)) * 8;\n	data = RB[rt];\n	data <<= offset;\n	data |= DM.read(addr & 0xFFFFFFFC) & ((1<<offset)-1);\n	DM.write(addr & 0xFFFFFFFC, data);\n	dbg_printf(\"Result = %#x\\n\", data);\n};\n\n//!Instruction addi behavior method.\nvoid ac_behavior( addi )\n{\n	dbg_printf(\"addi r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	RB[rt] = RB[rs] + imm;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	//Test overflow\n	if ( ((RB[rs] & 0x80000000) == (imm & 0x80000000)) &&\n			((imm & 0x80000000) != (RB[rt] & 0x80000000)) ) {\n		fprintf(stderr, \"EXCEPTION(addi): integer overflow.\\n\"); exit(EXIT_FAILURE);\n	}\n	reg_write = true;\n};\n\n//!Instruction addiu behavior method.\nvoid ac_behavior( addiu )\n{\n	dbg_printf(\"addiu r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	RB[rt] = RB[rs] + imm;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n};\n\n//!Instruction slti behavior method.\nvoid ac_behavior( slti )\n{\n	dbg_printf(\"slti r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	// Set the RD if RS< IMM\n	if( (ac_Sword) RB[rs] < (ac_Sword) imm )\n		RB[rt] = 1;\n	// Else reset RD\n	else\n		RB[rt] = 0;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n};\n\n//!Instruction sltiu behavior method.\nvoid ac_behavior( sltiu )\n{\n	dbg_printf(\"sltiu r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	// Set the RD if RS< IMM\n	if( (ac_Uword) RB[rs] < (ac_Uword) imm )\n		RB[rt] = 1;\n	// Else reset RD\n	else\n		RB[rt] = 0;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n};\n\n//!Instruction andi behavior method.\nvoid ac_behavior( andi )\n{	\n	dbg_printf(\"andi r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	RB[rt] = RB[rs] & (imm & 0xFFFF) ;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n};\n\n//!Instruction ori behavior method.\nvoid ac_behavior( ori )\n{	\n	dbg_printf(\"ori r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	RB[rt] = RB[rs] | (imm & 0xFFFF) ;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n};\n\n//!Instruction xori behavior method.\nvoid ac_behavior( xori )\n{	\n	dbg_printf(\"xori r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	RB[rt] = RB[rs] ^ (imm & 0xFFFF) ;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n};\n\n//!Instruction lui behavior method.\nvoid ac_behavior( lui )\n{	\n	dbg_printf(\"lui r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	// Load a constant in the upper 16 bits of a register\n	// To achieve the desired behaviour, the constant was shifted 16 bits left\n	// and moved to the target register ( rt )\n	RB[rt] = imm << 16;\n	dbg_printf(\"Result = %#x\\n\", RB[rt]);\n	reg_write = true;\n};\n\n//!Instruction add behavior method.\nvoid ac_behavior( add )\n{\n	nadds++;\n	dbg_printf(\"add r%d, r%d, r%d\\n\", rd, rs, rt);\n	RB[rd] = RB[rs] + RB[rt];\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n	//Test overflow\n	if ( ((RB[rs] & 0x80000000) == (RB[rd] & 0x80000000)) &&\n			((RB[rd] & 0x80000000) != (RB[rt] & 0x80000000)) ) {\n		fprintf(stderr, \"EXCEPTION(add): integer overflow.\\n\"); exit(EXIT_FAILURE);\n	}\n	reg_write = true;\n};\n\n//!Instruction addu behavior method.\nvoid ac_behavior( addu )\n{\n	dbg_printf(\"addu r%d, r%d, r%d\\n\", rd, rs, rt);\n	RB[rd] = RB[rs] + RB[rt];\n	//cout << \"  RS: \" << (unsigned int)RB[rs] << \" RT: \" << (unsigned int)RB[rt] << endl;\n	//cout << \"  Result =  \" <<  (unsigned int)RB[rd] <<endl;\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n	reg_write = true;\n};\n\n//!Instruction sub behavior method.\nvoid ac_behavior( sub )\n{\n	dbg_printf(\"sub r%d, r%d, r%d\\n\", rd, rs, rt);\n	RB[rd] = RB[rs] - RB[rt];\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n	//TODO: test integer overflow exception for sub\n	reg_write = true;\n};\n\n//!Instruction subu behavior method.\nvoid ac_behavior( subu )\n{\n	dbg_printf(\"subu r%d, r%d, r%d\\n\", rd, rs, rt);\n	RB[rd] = RB[rs] - RB[rt];\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n	reg_write = true;\n};\n\n//!Instruction slt behavior method.\nvoid ac_behavior( slt )\n{	\n	dbg_printf(\"slt r%d, r%d, r%d\\n\", rd, rs, rt);\n	// Set the RD if RS< RT\n	if( (ac_Sword) RB[rs] < (ac_Sword) RB[rt] )\n		RB[rd] = 1;\n	// Else reset RD\n	else\n		RB[rd] = 0;\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction sltu behavior method.\nvoid ac_behavior( sltu )\n{\n	dbg_printf(\"sltu r%d, r%d, r%d\\n\", rd, rs, rt);\n	// Set the RD if RS < RT\n	if( RB[rs] < RB[rt] )\n		RB[rd] = 1;\n	// Else reset RD\n	else\n		RB[rd] = 0;\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction instr_and behavior method.\nvoid ac_behavior( instr_and )\n{\n	dbg_printf(\"instr_and r%d, r%d, r%d\\n\", rd, rs, rt);\n	RB[rd] = RB[rs] & RB[rt];\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction instr_or behavior method.\nvoid ac_behavior( instr_or )\n{\n	dbg_printf(\"instr_or r%d, r%d, r%d\\n\", rd, rs, rt);\n	RB[rd] = RB[rs] | RB[rt];\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction instr_xor behavior method.\nvoid ac_behavior( instr_xor )\n{\n	dbg_printf(\"instr_xor r%d, r%d, r%d\\n\", rd, rs, rt);\n	RB[rd] = RB[rs] ^ RB[rt];\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction instr_nor behavior method.\nvoid ac_behavior( instr_nor )\n{\n	dbg_printf(\"nor r%d, r%d, r%d\\n\", rd, rs, rt);\n	RB[rd] = ~(RB[rs] | RB[rt]);\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction nop behavior method.\nvoid ac_behavior( nop )\n{  \n	dbg_printf(\"nop\\n\");\n};\n\n//!Instruction sll behavior method.\nvoid ac_behavior( sll )\n{  \n	dbg_printf(\"sll r%d, r%d, %d\\n\", rd, rs, shamt);\n	RB[rd] = RB[rt] << shamt;\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction srl behavior method.\nvoid ac_behavior( srl )\n{\n	dbg_printf(\"srl r%d, r%d, %d\\n\", rd, rs, shamt);\n	RB[rd] = RB[rt] >> shamt;\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction sra behavior method.\nvoid ac_behavior( sra )\n{\n	dbg_printf(\"sra r%d, r%d, %d\\n\", rd, rs, shamt);\n	RB[rd] = (ac_Sword) RB[rt] >> shamt;\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction sllv behavior method.\nvoid ac_behavior( sllv )\n{\n	dbg_printf(\"sllv r%d, r%d, r%d\\n\", rd, rt, rs);\n	RB[rd] = RB[rt] << (RB[rs] & 0x1F);\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction srlv behavior method.\nvoid ac_behavior( srlv )\n{\n	dbg_printf(\"srlv r%d, r%d, r%d\\n\", rd, rt, rs);\n	RB[rd] = RB[rt] >> (RB[rs] & 0x1F);\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction srav behavior method.\nvoid ac_behavior( srav )\n{\n	dbg_printf(\"srav r%d, r%d, r%d\\n\", rd, rt, rs);\n	RB[rd] = (ac_Sword) RB[rt] >> (RB[rs] & 0x1F);\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction mult behavior method.\nvoid ac_behavior( mult )\n{\n	dbg_printf(\"mult r%d, r%d\\n\", rs, rt);\n\n	long long result;\n	int half_result;\n\n	result = (ac_Sword) RB[rs];\n	result *= (ac_Sword) RB[rt];\n\n	half_result = (result & 0xFFFFFFFF);\n	// Register LO receives 32 less significant bits\n	lo = half_result;\n\n	half_result = ((result >> 32) & 0xFFFFFFFF);\n	// Register HI receives 32 most significant bits\n	hi = half_result ;\n\n	dbg_printf(\"Result = %#llx\\n\", result);\n	reg_write = true;\n};\n\n//!Instruction multu behavior method.\nvoid ac_behavior( multu )\n{\n	dbg_printf(\"multu r%d, r%d\\n\", rs, rt);\n\n	unsigned long long result;\n	unsigned int half_result;\n\n	result  = RB[rs];\n	result *= RB[rt];\n\n	half_result = (result & 0xFFFFFFFF);\n	// Register LO receives 32 less significant bits\n	lo = half_result;\n\n	half_result = ((result>>32) & 0xFFFFFFFF);\n	// Register HI receives 32 most significant bits\n	hi = half_result ;\n\n	dbg_printf(\"Result = %#llx\\n\", result);\n	reg_write = true;\n};\n\n//!Instruction div behavior method.\nvoid ac_behavior( div )\n{\n	dbg_printf(\"div r%d, r%d\\n\", rs, rt);\n	// Register LO receives quotient\n	lo = (ac_Sword) RB[rs] / (ac_Sword) RB[rt];\n	// Register HI receives remainder\n	hi = (ac_Sword) RB[rs] % (ac_Sword) RB[rt];\n	reg_write = true;\n};\n\n//!Instruction divu behavior method.\nvoid ac_behavior( divu )\n{\n	dbg_printf(\"divu r%d, r%d\\n\", rs, rt);\n	// Register LO receives quotient\n	lo = RB[rs] / RB[rt];\n	// Register HI receives remainder\n	hi = RB[rs] % RB[rt];\n	reg_write = true;\n};\n\n//!Instruction mfhi behavior method.\nvoid ac_behavior( mfhi )\n{\n	dbg_printf(\"mfhi r%d\\n\", rd);\n	RB[rd] = hi;\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction mthi behavior method.\nvoid ac_behavior( mthi )\n{\n	dbg_printf(\"mthi r%d\\n\", rs);\n	hi = RB[rs];\n	dbg_printf(\"Result = %#x\\n\", hi);\n};\n\n//!Instruction mflo behavior method.\nvoid ac_behavior( mflo )\n{\n	dbg_printf(\"mflo r%d\\n\", rd);\n	RB[rd] = lo;\n	dbg_printf(\"Result = %#x\\n\", RB[rd]);\n};\n\n//!Instruction mtlo behavior method.\nvoid ac_behavior( mtlo )\n{\n	dbg_printf(\"mtlo r%d\\n\", rs);\n	lo = RB[rs];\n	dbg_printf(\"Result = %#x\\n\", lo);\n};\n\n//!Instruction j behavior method.\nvoid ac_behavior( j )\n{\n	dbg_printf(\"j %d\\n\", addr);\n	addr = addr << 2;\n#ifndef NO_NEED_PC_UPDATE\n	npc =  (ac_pc & 0xF0000000) | addr;\n#endif \n	dbg_printf(\"Target = %#x\\n\", (ac_pc & 0xF0000000) | addr );\n};\n\n//!Instruction jal behavior method.\nvoid ac_behavior( jal )\n{\n	dbg_printf(\"jal %d\\n\", addr);\n	// Save the value of PC + 8 (return address) in $ra ($31) and\n	// jump to the address given by PC(31...28)||(addr<<2)\n	// It must also flush the instructions that were loaded into the pipeline\n	RB[Ra] = ac_pc+4; //ac_pc is pc+4, we need pc+8\n\n	addr = addr << 2;\n#ifndef NO_NEED_PC_UPDATE\n	npc = (ac_pc & 0xF0000000) | addr;\n#endif \n\n	dbg_printf(\"Target = %#x\\n\", (ac_pc & 0xF0000000) | addr );\n	dbg_printf(\"Return = %#x\\n\", ac_pc+4);\n};\n\n//!Instruction jr behavior method.\nvoid ac_behavior( jr )\n{\n	dbg_printf(\"jr r%d\\n\", rs);\n	// Jump to the address stored on the register reg[RS]\n	// It must also flush the instructions that were loaded into the pipeline\n#ifndef NO_NEED_PC_UPDATE\n	npc = RB[rs], 1;\n#endif \n	dbg_printf(\"Target = %#x\\n\", RB[rs]);\n};\n\n//!Instruction jalr behavior method.\nvoid ac_behavior( jalr )\n{\n	dbg_printf(\"jalr r%d, r%d\\n\", rd, rs);\n	// Save the value of PC + 8(return address) in rd and\n	// jump to the address given by [rs]\n\n#ifndef NO_NEED_PC_UPDATE\n	npc = RB[rs], 1;\n#endif \n	dbg_printf(\"Target = %#x\\n\", RB[rs]);\n\n	if( rd == 0 )  //If rd is not defined use default\n		rd = Ra;\n	RB[rd] = ac_pc+4;\n	dbg_printf(\"Return = %#x\\n\", ac_pc+4);\n};\n\n//!Instruction beq behavior method.\nvoid ac_behavior( beq )\n{\n	cout << \"first\" << op << endl;\n	branch_count++;\n	branch_state_aux = false;\n	dbg_printf(\"beq r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	if( RB[rs] == RB[rt] ){\n#ifndef NO_NEED_PC_UPDATE\n		npc = ac_pc + (imm<<2);\n#endif \n		dbg_printf(\"Taken to %#x\\n\", ac_pc + (imm<<2));\n		not_taken++;\n		branch_state_aux = true;\n	}	else always_taken++;\n	cout << \"npc BEQ: \" << npc << \" ac_pc: \" << ac_pc << \" imm: \" << imm << endl << endl;\n	OneBitFunc(imm, branch_state_aux);\n	NaiveFunc(branch_state_aux);\n};\n\n//!Instruction bne behavior method.\nvoid ac_behavior( bne )\n{\n	branch_count++;\n	branch_state_aux = false;\n	dbg_printf(\"bne r%d, r%d, %d\\n\", rt, rs, imm & 0xFFFF);\n	if( RB[rs] != RB[rt] ){\n#ifndef NO_NEED_PC_UPDATE\n		npc = ac_pc + (imm<<2);\n#endif \n		dbg_printf(\"Taken to %#x\\n\", ac_pc + (imm<<2));\n		not_taken++;\n		branch_state_aux = true;\n	}	else always_taken++;\n	OneBitFunc(imm, branch_state_aux);\n	NaiveFunc(branch_state_aux);\n};\n\n//!Instruction blez behavior method.\nvoid ac_behavior( blez )\n{\n	branch_count++;\n	branch_state_aux = false;\n	dbg_printf(\"blez r%d, %d\\n\", rs, imm & 0xFFFF);\n	if( (RB[rs] == 0 ) || (RB[rs]&0x80000000 ) ){\n#ifndef NO_NEED_PC_UPDATE\n		npc = ac_pc + (imm<<2), 1;\n#endif \n		dbg_printf(\"Taken to %#x\\n\", ac_pc + (imm<<2));\n		not_taken++;\n		branch_state_aux = true;\n	}	else always_taken++;\n	OneBitFunc(imm, branch_state_aux);\n	NaiveFunc(branch_state_aux);\n};\n\n//!Instruction bgtz behavior method.\nvoid ac_behavior( bgtz )\n{\n	branch_count++;\n	branch_state_aux = false;\n	dbg_printf(\"bgtz r%d, %d\\n\", rs, imm & 0xFFFF);\n	if( !(RB[rs] & 0x80000000) && (RB[rs]!=0) ){\n#ifndef NO_NEED_PC_UPDATE\n		npc = ac_pc + (imm<<2);\n#endif \n		dbg_printf(\"Taken to %#x\\n\", ac_pc + (imm<<2));\n		not_taken++;\n		branch_state_aux = true;\n	}	else always_taken++;\n	OneBitFunc(imm, branch_state_aux);\n	NaiveFunc(branch_state_aux);\n};\n\n//!Instruction bltz behavior method.\nvoid ac_behavior( bltz )\n{\n	branch_count++;\n	branch_state_aux = false;\n	dbg_printf(\"bltz r%d, %d\\n\", rs, imm & 0xFFFF);\n	if( RB[rs] & 0x80000000 ){\n#ifndef NO_NEED_PC_UPDATE\n		npc = ac_pc + (imm<<2);\n#endif \n		dbg_printf(\"Taken to %#x\\n\", ac_pc + (imm<<2));\n		not_taken++;\n		branch_state_aux = true;\n	}	else always_taken++;\n	OneBitFunc(imm, branch_state_aux);\n	NaiveFunc(branch_state_aux);\n};\n\n//!Instruction bgez behavior method.\nvoid ac_behavior( bgez )\n{\n	branch_count++;\n	branch_state_aux = false;\n	dbg_printf(\"bgez r%d, %d\\n\", rs, imm & 0xFFFF);\n	if( !(RB[rs] & 0x80000000) ){\n#ifndef NO_NEED_PC_UPDATE\n		npc = ac_pc + (imm<<2);\n#endif \n		dbg_printf(\"Taken to %#x\\n\", ac_pc + (imm<<2));\n		not_taken++;\n		branch_state_aux = true;\n	}	else always_taken++;\n	OneBitFunc(imm, branch_state_aux);\n	NaiveFunc(branch_state_aux);\n};\n\n//!Instruction bltzal behavior method.\nvoid ac_behavior( bltzal )\n{\n	branch_count++;\n	branch_state_aux = false;\n	dbg_printf(\"bltzal r%d, %d\\n\", rs, imm & 0xFFFF);\n	RB[Ra] = ac_pc+4; //ac_pc is pc+4, we need pc+8\n	if( RB[rs] & 0x80000000 ){\n#ifndef NO_NEED_PC_UPDATE\n		npc = ac_pc + (imm<<2);\n#endif \n		dbg_printf(\"Taken to %#x\\n\", ac_pc + (imm<<2));\n		not_taken++;\n		branch_state_aux = true;\n	}	else always_taken++;\n	OneBitFunc(imm, branch_state_aux);\n	NaiveFunc(branch_state_aux);\n	dbg_printf(\"Return = %#x\\n\", ac_pc+4);\n};\n\n//!Instruction bgezal behavior method.\nvoid ac_behavior( bgezal )\n{\n	branch_count++;\n	branch_state_aux = false;\n	dbg_printf(\"bgezal r%d, %d\\n\", rs, imm & 0xFFFF);\n	RB[Ra] = ac_pc+4; //ac_pc is pc+4, we need pc+8\n	if( !(RB[rs] & 0x80000000) ){\n#ifndef NO_NEED_PC_UPDATE\n		npc = ac_pc + (imm<<2);\n#endif \n		dbg_printf(\"Taken to %#x\\n\", ac_pc + (imm<<2));\n		not_taken++;\n		branch_state_aux = true;\n	}	else always_taken++;\n	OneBitFunc(imm, branch_state_aux);\n	NaiveFunc(branch_state_aux);\n	dbg_printf(\"Return = %#x\\n\", ac_pc+4);\n};\n\n//!Instruction sys_call behavior method.\nvoid ac_behavior( sys_call )\n{\n	dbg_printf(\"syscall\\n\");\n	stop();\n}\n\n//!Instruction instr_break behavior method.\nvoid ac_behavior( instr_break )\n{\n	fprintf(stderr, \"instr_break behavior not implemented.\\n\"); \n	exit(EXIT_FAILURE);\n}\n",
			"file": "mips1_isa.cpp",
			"file_size": 27018,
			"file_write_time": 1368257571000000,
			"settings":
			{
				"buffer_size": 26144,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/marcelotoledo/Desktop/branchpredictor.cpp",
			"settings":
			{
				"buffer_size": 3569,
				"line_ending": "Unix",
				"name": "#include \"branchpredictor.h\""
			}
		},
		{
			"file": "/Users/marcelotoledo/Desktop/test.cpp",
			"settings":
			{
				"buffer_size": 479,
				"line_ending": "Unix",
				"name": "#include \"branchpredictor.h\""
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 125.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Users/marcelotoledo/Desktop/mc723p2/pipeline.cpp",
		"/Users/marcelotoledo/Desktop/mc723p2/mips1.H",
		"/Users/marcelotoledo/Desktop/mc723p2/mips1_arch_ref.H",
		"/Users/marcelotoledo/Desktop/mc723p2/mips1_isa.H",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/Makefile",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/main.cpp",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1.ac",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1.H",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_arch.cpp",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_arch.H",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_arch_ref.H",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_arch_ref.cpp",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_gdb_funcs.cpp",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_isa.cpp.tmpl",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_isa.H",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_isa_init.cpp",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_isa.cpp",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_syscall.cpp",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_syscall.H",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_syscall.H.tmpl",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/modifiers",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1_bhv_macros.H",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/mips1.x",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 2/mc723p2/main.cpp.tmpl",
		"/Users/marcelotoledo/Desktop/Questões a serem tratadas hoje a noite (25:13)",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/readn.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/sandbox.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/methodmapping.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/wrappers.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/methodmapping.h",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/error.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/danube_server.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/dbhandle.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/writen.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/readline.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/tcp_listen.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/tcpserver.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/unp.h",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/bookentry.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/wrapunix.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/write_fd.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/writable_timeo.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/wrapstdio.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/m_server/signal.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/wrapsock.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/wraplib.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/writen.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/unp.h",
		"/Users/marcelotoledo/Desktop/unpv13e/config.h",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/signal.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/readline.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/str_echo.c",
		"/Users/marcelotoledo/Desktop/unpv13e/lib/tcp_listen.c",
		"/Users/marcelotoledo/Desktop/unpv13e/server/Makefile",
		"/Users/marcelotoledo/Desktop/unpv13e/tcpcliserv/sigchldwaitpid.c",
		"/Users/marcelotoledo/Desktop/unpv13e/tcpcliserv/sigchldwait.c",
		"/Users/marcelotoledo/Desktop/unpv13e/tcpcliserv/sigchldwait.lc",
		"/Users/marcelotoledo/Desktop/unpv13e/server/serv01.c",
		"/Users/marcelotoledo/Desktop/unpv13e/README",
		"/Users/marcelotoledo/Desktop/autoconf-2.69/README",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/tcpserver.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/helper.h",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/helper.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/unp.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/unp.h",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/database/test.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/database/methodmapping.h",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/database/methodmapping.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/Makefile",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/database/danubedb.sublime-project",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/database/bookentry.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/database/bookentry.h",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/database/dbhandle.h",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/database/dbhandle.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/server/database/dbdefinitions.h",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 1/f_pc_names.p",
		"/Users/marcelotoledo/Desktop/selector-stub.js",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC723/Projeto 1/f_pc_scores.p",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/auxiliar.c",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/auxiliar.h",
		"/Users/marcelotoledo/Dropbox/UNICAMP/MC823/Danube/main.c",
		"/Library/Python/2.7/site-packages/PIL.pth",
		"/Users/marcelotoledo/Desktop/eternidade",
		"/Users/marcelotoledo/Desktop/s2messagereceive",
		"/Users/marcelotoledo/Desktop/s2messagesend",
		"/Users/marcelotoledo/Desktop/eternidade.txt",
		"/Users/marcelotoledo/Desktop/python_test/classes/node.py",
		"/Users/marcelotoledo/Desktop/python_test/classes/order.py",
		"/Users/marcelotoledo/Desktop/python_test/classes/point.py",
		"/Users/marcelotoledo/Desktop/python_test/classes/route.py",
		"/Users/marcelotoledo/Desktop/huws-sms-db.sqlite-wal",
		"/Users/marcelotoledo/Desktop/t"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"add",
			"ac_pc",
			") ",
			"sig_c",
			"));\n",
			"response"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"entry"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/Users/marcelotoledo/Desktop/branchpredictor.h",
					"settings":
					{
						"buffer_size": 1294,
						"regions":
						{
						},
						"selection":
						[
							[
								636,
								636
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 238.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "pipeline.h",
					"settings":
					{
						"buffer_size": 308,
						"regions":
						{
						},
						"selection":
						[
							[
								51,
								51
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "mips1_isa.cpp",
					"settings":
					{
						"buffer_size": 26144,
						"regions":
						{
						},
						"selection":
						[
							[
								4235,
								4235
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		},
		{
			"sheets":
			[
				{
					"buffer": 3,
					"file": "/Users/marcelotoledo/Desktop/branchpredictor.cpp",
					"settings":
					{
						"buffer_size": 3569,
						"regions":
						{
						},
						"selection":
						[
							[
								591,
								591
							]
						],
						"settings":
						{
							"auto_name": "#include \"branchpredictor.h\"",
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/Users/marcelotoledo/Desktop/test.cpp",
					"settings":
					{
						"buffer_size": 479,
						"regions":
						{
						},
						"selection":
						[
							[
								479,
								479
							]
						],
						"settings":
						{
							"auto_name": "#include \"branchpredictor.h\"",
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.430013624768,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 25.0
	},
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
		],
		"width": 380.0
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true
}
